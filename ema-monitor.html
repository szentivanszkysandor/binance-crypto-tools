<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EMA/RSI/MACD/ATR Monitor – Live (Binance)</title>
<style>
  :root{--bg:#0b1220;--panel:#0f1629;--fg:#e6edf3;--muted:#8da2c0;--line:#1b2336;--ok:#34d399;--warn:#fbbf24;--err:#f87171;--bull:#16a34a;--bear:#ef4444}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px system-ui,Segoe UI,Roboto,Inter,Arial}
  header{display:flex;flex-wrap:wrap;gap:10px;align-items:center;padding:12px 14px;border-bottom:1px solid #1e293b}
  header h1{font-size:16px;margin:0 8px 0 0;color:#cbd5e1}
  input,select,button,label{color:var(--fg)}
  input,select,button{background:#0f1a2b;border:1px solid #233552;border-radius:10px;padding:8px 10px}
  input::placeholder{color:#8aa0b6}
  button{cursor:pointer;transition:.15s}
  button:hover{filter:brightness(1.08)}
  .muted{color:var(--muted)}
  main{padding:14px}
  .boards{display:block;gap:14px}
  .card{margin-bottom:15px;background:var(--panel);border:1px solid var(--line);border-radius:14px;overflow:hidden}
  .head{display:flex;gap:10px;align-items:center;padding:10px 12px;border-bottom:1px solid var(--line)}
  .pill{font-weight:700;letter-spacing:.3px;border-radius:999px;padding:4px 10px;background:#0e1a2e;border:1px solid #223552}
  .grow{flex:1}
  .price{font-weight:700}
  .close{background:#1a243b;border:1px solid #2b3759;border-radius:8px;padding:4px 8px;cursor:pointer}
  .head-status{display:flex;justify-content:center;align-items:center;min-height:18px;padding:6px 12px;border-bottom:1px solid var(--line)}
  .status{font-size:12px;color:var(--muted)}
  table{width:100%;border-collapse:collapse;font-variant-numeric:tabular-nums}
  th,td{padding:8px 10px;border-bottom:1px solid var(--line);text-align:right;white-space:nowrap}
  th{color:#9aa4b2;font-weight:600;font-size:12px}
  td:first-child,th:first-child{text-align:left}
  .green{color:#34d399}
  .red{color:#f87171}
  .badge{padding:2px 6px;border-radius:6px;border:1px solid #2a3c59;font-size:12px}
  .bull{color:#16a34a;background:#062f22;border-color:#0b5137}
  .bear{color:#ef4444;background:#3a0e12;border-color:#7f1d1d}
  .neutral{color:#eab308;background:#2d2507;border-color:#4d3b05}
  .alert{outline:2px solid var(--warn); outline-offset:-2px; background:rgba(251,191,36,0.05)}
  .rsi-ob{color:#ef4444}
  .rsi-os{color:#34d399}
  .heat{display:inline-block;padding:2px 6px;border-radius:6px}
  .drawer{position:fixed;right:16px;top:72px;width:520px;max-width:95vw;max-height:86vh;overflow:auto;background:var(--panel);border:1px solid #1b2336;border-radius:12px;box-shadow:0 10px 40px rgba(0,0,0,.5);padding:12px;display:none;z-index:50}
  .drawer.open{display:block}
  .drawer h3{margin:4px 0 10px}
  .row{display:flex;gap:8px;align-items:center;margin:8px 0}
  .row label{flex:1}
  .row textarea{flex:1}
  .btns{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}
  .iv-grid{display:grid;grid-template-columns:repeat(6,minmax(0,1fr));gap:6px}
  .iv-item{display:flex;align-items:center;gap:6px}
</style>
</head>
<body>
  <header>
    <h1>EMA/RSI/MACD/ATR Monitor – Live (Binance)</h1>

    <label>Pairs (comma-separated): 
      <input id="symInput" placeholder="e.g. BTCUSDC,ETHUSDC,BNBUSDC,SOLUSDC" style="min-width:280px" />
    </label>

    <fieldset style="border:1px solid #233552;border-radius:10px;padding:6px 10px">
      <legend style="font-size:12px;color:#9aa4b2">Timeframes</legend>
      <label><input type="checkbox" class="ival" value="1m">1m</label>
      <label><input type="checkbox" class="ival" value="3m">3m</label>
      <label><input type="checkbox" class="ival" value="5m" checked>5m</label>
      <label><input type="checkbox" class="ival" value="15m" checked>15m</label>
      <label><input type="checkbox" class="ival" value="30m">30m</label>
      <label><input type="checkbox" class="ival" value="1h" checked>1h</label>
      <label><input type="checkbox" class="ival" value="2h">2h</label>
      <label><input type="checkbox" class="ival" value="4h" checked>4h</label>
      <label><input type="checkbox" class="ival" value="1d" checked>1d</label>
    </fieldset>

    <button id="addBtn">Add / Extend</button>
    <button id="refreshBtn">Refresh</button>
    <button id="btnSettings">⚙️ Settings</button>
    <button id="btnHelp">❓ Help</button>

    <span id="status" class="muted" style="margin-left:auto">Done.</span>
  </header>

  <main>
    <div class="boards" id="boards"></div>
  </main>

  <div id="settings" class="drawer">
    <h3>Defaults</h3>

    <div class="row">
      <label for="defPairs">Default pairs (comma-separated):</label>
      <textarea id="defPairs" rows="3" placeholder="e.g. BTCUSDC,ETHUSDC,BNBUSDC,SOLUSDC"></textarea>
    </div>

    <div class="row" style="flex-direction:column;align-items:stretch">
      <label>Default timeframes:</label>
      <div class="iv-grid" id="defIntervals">
        <label class="iv-item"><input type="checkbox" value="1m">1m</label>
        <label class="iv-item"><input type="checkbox" value="3m">3m</label>
        <label class="iv-item"><input type="checkbox" value="5m">5m</label>
        <label class="iv-item"><input type="checkbox" value="15m">15m</label>
        <label class="iv-item"><input type="checkbox" value="30m">30m</label>
        <label class="iv-item"><input type="checkbox" value="1h">1h</label>
        <label class="iv-item"><input type="checkbox" value="2h">2h</label>
        <label class="iv-item"><input type="checkbox" value="4h">4h</label>
        <label class="iv-item"><input type="checkbox" value="1d">1d</label>
      </div>
    </div>

    <div class="row">
      <label for="defPeriod">Default period (s):</label>
      <input id="defPeriod" type="number" min="5" max="600" value="30" style="width:120px">
    </div>

    <div class="row" style="flex-direction:column;align-items:stretch">
      <label><strong>Advanced:</strong></label>
      <div class="row">
        <label for="defThrottleMs">Compute throttle (ms):</label>
        <input id="defThrottleMs" type="number" min="200" max="10000" step="50" value="1500" style="width:140px">
      </div>
      <div class="row">
        <label for="defMinBars">Min. closed bars (for stable calc):</label>
        <input id="defMinBars" type="number" min="100" max="1000" step="10" value="350" style="width:140px">
      </div>
      <div class="row">
        <label for="defMaxFps">Max FPS (price drawing):</label>
        <input id="defMaxFps" type="number" min="1" max="60" step="1" value="8" style="width:140px">
      </div>
    </div>

    <small class="muted">
      “Save + apply now” deduplikál, max 4 default párt ment, bezár + újranyit ezekkel (timeframe-ekkel együtt).
    </small>
    <div class="btns">
      <button id="btnSaveDefaults">Save</button>
      <button id="btnApplyDefaults">Save + apply now</button>
      <button id="btnCloseSettings">Close</button>
    </div>
  </div>

  <div id="help" class="drawer" aria-label="Help">
<h2>User Guide</h2>
<h3>What is this?</h3>
<p>
  <b>EMA/RSI/MACD/ATR Monitor – Live (Binance)</b> shows live market stats for up to four Binance Spot pairs at once. 
  Each <i>card</i> is a symbol with a simple table per timeframe and a <b>Consensus</b> summary in the header. 
  Green/red coloring helps you see trend direction at a glance. 
</p>

<h3>Quick start</h3>
<ol>
  <li>Type symbols (e.g. <code>BTCUSDC, ETHUSDC</code>) and select timeframes (e.g. <code>5m, 15m, 1h, 4h, 1d</code>).</li>
  <li>Click <b>Add / Extend</b> to open cards (max <b>4</b> at the same time).</li>
  <li>Use <b>Refresh</b> anytime to recalc indicators from Binance candles.</li>
  <li>In <b>Settings</b> you can save defaults; <i>Save + apply now</i> reopens exactly those defaults.</li>
</ol>

<h3>How to read the table</h3>
<ul>
  <li><b>Price (live)</b>: last price. Green when above the long-term average (EMA200), red when below. Easy trend cue.</li>
  <li><b>EMA7/20/50/200</b>: short → long moving averages. A clean “stack” (7&gt;20&gt;50&gt;200) supports uptrend; the reverse supports downtrend.</li>
  <li><b>EMA50 slope</b>: ↗ up, ↘ down, → flat — a quick momentum hint for that timeframe.</li>
  <li><b>RSI(14)</b>: <i>Overbought</i> (≥70), <i>Oversold</i> (≤30), or <i>Neutral</i> for context on stretch/mean-revert.</li>
  <li><b>MACD</b>: shows a simple <i>Bull cross / Bear cross / No cross</i> label to confirm or warn the trend.</li>
  <li><b>ATR(14)</b>: volatility gauge; higher ATR means bigger typical swings.</li>
  <li><b>Signal</b>: the app’s simple read: <b>BUY</b>, <b>SELL</b>, <b>Watch</b>, or <b>Neutral</b> for that timeframe.</li>
</ul>

<h3>Consensus (card header)</h3>
<p>
  Shows how many rows (timeframes) currently say <b>BUY</b> vs <b>SELL</b>. 
  Mixed or low counts = mixed market; many BUYs or many SELLs = clearer direction. 
</p>

<h3>What to focus on</h3>
<ul>
  <li><b>Direction first</b>: is Price mostly above or below EMA200? Is EMA50 sloping ↗ or ↘?</li>
  <li><b>Agreement</b>: do multiple timeframes give the same Signal? That adds confidence.</li>
  <li><b>Context</b>: extreme RSI (70/30) or rising ATR = more risk of sharp reversals. Combine with key price levels.</li>
</ul>

<h3>Tips</h3>
<ul>
  <li>Start with 2–3 timeframes (e.g., 15m, 1h, 4h). Add more only if needed.</li>
  <li>If numbers look odd right after opening, wait until status shows <b>Live</b> — backfill is finishing.</li>
  <li>On slower PCs, reduce timeframes or raise <i>Compute throttle</i> / lower <i>Max FPS</i> in Settings.</li>
</ul>

<h3>Troubleshooting</h3>
<ul>
  <li><b>No data</b>: click <b>Refresh</b> or reopen the card; check your connection.</li>
  <li><b>Too many cards</b>: close one — the app allows up to four open symbols.</li>
</ul>
 
  <div class="btns" style="margin-top:10px">
   <button id="btnCloseHelp">Close</button>
  </div>
  </div>

<script>
(() => {
  const $ = (s)=>document.querySelector(s);
  const el = (id)=>document.getElementById(id);

  // ---------- DOM ---------- //
  const symInput = el('symInput');
  const addBtn = el('addBtn');
  const refreshBtn = el('refreshBtn');
  const statusEl = el('status');
  const boards = el('boards');
  const CHECKS = Array.from(document.querySelectorAll('.ival'));
  const ALL_INTS = ['1m','3m','5m','15m','30m','1h','2h','4h','1d'];

  // ---------- Settings ---------- //
  const drawer = el('settings');
  const btnSettings = el('btnSettings');
  const btnSaveDefaults = el('btnSaveDefaults');
  const btnApplyDefaults = el('btnApplyDefaults');
  const btnCloseSettings = el('btnCloseSettings');
  const defPairsEl = el('defPairs');
  const defIntervalsWrap = el('defIntervals');
  const defPeriodEl = el('defPeriod');
  const defThrottleMsEl = el('defThrottleMs');
  const defMinBarsEl = el('defMinBars');
  const defMaxFpsEl = el('defMaxFps');
  const helpDrawer = el('help');
  const btnHelp = el('btnHelp');
  const btnCloseHelp = el('btnCloseHelp');

  // ---------- LocalStorage keys ---------- //
  const LS_STATE   = 'ema_state_v2';
  const LS_DEF_PAIRS = 'ema_defaults_pairs';
  const LS_DEF_INTS  = 'ema_defaults_intervals';
  const LS_DEF_PER   = 'ema_defaults_period';
  const LS_ADV       = 'ema_adv_settings_v1';
  const LS_TA_CACHE  = 'ema_ta_cache_v1';

  // ---------- Defaults ---------- //
  const DEFAULT_PAIRS = ['BTCUSDC','ETHUSDC','BNBUSDC','SOLUSDC'];
  const DEFAULT_INTS  = ['5m','15m','1h','4h','1d'];
  const DEFAULT_PERIOD = 30;
  const DEFAULT_ADV = { throttleMs:1500, minBars:350, maxFps:8 };

  // ---------- Load/Save ---------- //
  function loadDefaultPairs(){
    try{ const j=JSON.parse(localStorage.getItem(LS_DEF_PAIRS)||'null');
      if(Array.isArray(j)&&j.length) return j.map(s=>String(s).toUpperCase().trim()).filter(Boolean);
    }catch{}
    return DEFAULT_PAIRS.slice();
  }
  function loadDefaultIntervals(){
    try{ const j=JSON.parse(localStorage.getItem(LS_DEF_INTS)||'null');
      const arr=Array.isArray(j)?j:DEFAULT_INTS; return arr.filter(v=>ALL_INTS.includes(v));
    }catch{}
    return DEFAULT_INTS.slice();
  }
  function loadDefaultPeriod(){ const p=parseInt(localStorage.getItem(LS_DEF_PER)||DEFAULT_PERIOD,10);
    return Number.isFinite(p) ? Math.max(5,Math.min(600,p)) : DEFAULT_PERIOD; }
  function loadAdv(){ try{
      const j=JSON.parse(localStorage.getItem(LS_ADV)||'null')||DEFAULT_ADV;
      return {
        throttleMs:Math.max(200,Math.min(10000,Number(j.throttleMs)||DEFAULT_ADV.throttleMs)),
        minBars:   Math.max(100,Math.min(1000, Number(j.minBars)||DEFAULT_ADV.minBars)),
        maxFps:    Math.max(1,  Math.min(60,   Number(j.maxFps)||DEFAULT_ADV.maxFps)),
      };
    }catch{ return {...DEFAULT_ADV}; } }
  function saveAdv(v){ try{ localStorage.setItem(LS_ADV, JSON.stringify(v)); }catch{} }

  // ---------- State ---------- //
  let COMPUTE_THROTTLE_MS = loadAdv().throttleMs;
  let MIN_BARS_FOR_STABLE = loadAdv().minBars;
  let MAX_FPS = loadAdv().maxFps;

  const state = loadState();
  function loadState(){
    try{
      const j = JSON.parse(localStorage.getItem(LS_STATE)||'null');
      if(!j){
        const pairs = loadDefaultPairs().slice(0,4);
        const ivs = loadDefaultIntervals();
        return { list: pairs.map(sym=>({sym, intervals:[...ivs]})), auto:true, period:loadDefaultPeriod() };
      }
      j.list = Array.isArray(j.list) ? j.list.filter(x=>x && x.sym && Array.isArray(x.intervals)) : [];
      j.list.forEach(x=> x.intervals = x.intervals.filter(v=>ALL_INTS.includes(v)));
      if (j.list.length>4) j.list=j.list.slice(0,4);
      j.auto = !!j.auto;
      j.period = Math.max(5, Math.min(600, Number(j.period)||loadDefaultPeriod()));
      return j;
    }catch{
      const pairs = loadDefaultPairs().slice(0,4);
      const ivs = loadDefaultIntervals();
      return { list: pairs.map(sym=>({sym, intervals:[...ivs]})), auto:true, period:loadDefaultPeriod() };
    }
  }
  function saveState(){ try{ localStorage.setItem(LS_STATE, JSON.stringify(state)); }catch{} }

  // ---------- TA cache ---------- //
  function loadTaCache(){ try{ return JSON.parse(localStorage.getItem(LS_TA_CACHE)||'{}') }catch{ return {} } }
  const taCache = loadTaCache();
  function taKey(sym, iv){ return `${sym}__${iv}` }
  function saveTaRec(sym, iv, rec){
    taCache[taKey(sym, iv)] = { e7:rec.e7,e20:rec.e20,e50:rec.e50,e200:rec.e200,rsi:rec.rsi,dif:rec.dif,dea:rec.dea,macd:rec.macd,atr:rec.atr,ts:rec.ts };
    try{ localStorage.setItem(LS_TA_CACHE, JSON.stringify(taCache)); }catch{}
  }

  // ---------- Exchange Info ---------- //
  async function fetchExchangeInfo(sym){
    try{
      const r=await fetch(`https://api.binance.com/api/v3/exchangeInfo?symbol=${encodeURIComponent(sym)}`,{cache:'force-cache'});
      if(!r.ok) throw new Error('HTTP '+r.status);
      const j=await r.json(); const info=(j.symbols&&j.symbols[0])||null; if(!info) return null;
      const pf=(info.filters||[]).find(f=>f.filterType==='PRICE_FILTER');
      const ts = pf?.tickSize || '0.00000001';
      const dec = String(ts).includes('.') ? String(ts).replace(/0+$/,'').split('.')[1].length : 0;
      return { tickDecimals: dec };
    }catch{ return null; }
  }

  // ---------- Runtime ----------  //
  const symData = new Map();
  function ensureSym(sym){
    if(!symData.has(sym)){
      symData.set(sym, {
        meta:null,
        lastPrice:null,lastTs:null,
        ema:new Map(),
        kCache:new Map(),
        lastCalcTs:new Map(),
        priceDec:6,
        raf:false, pricePaintTs:0
      });
      fetchExchangeInfo(sym).then(meta=>{ const d=symData.get(sym); if(d&&meta){ d.meta=meta; d.priceDec=meta.tickDecimals??6; } });
    }
    return symData.get(sym);
  }

  // ---------- Formatters ---------- //
  const fmtN=(n,d=6)=>Number.isFinite(n)?(Math.abs(n)>=1?n.toFixed(Math.min(8,d)):n.toPrecision(6)).replace(/\.?0+$/,''):'—';
  const fmtPct=(x)=>Number.isFinite(x)?(x>=0?'+':'')+x.toFixed(2)+'%':'—';
  const htime=(ms)=>new Date(ms).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});
  function fmtPx(sym, n){ const d=ensureSym(sym); const dec=Math.max(0,Math.min(10,d.priceDec||6)); return Number.isFinite(n)? n.toFixed(dec) : '—'; }

  // ---------- TA ---------- //
  function EMA(arr, len){const k=2/(len+1),out=Array(arr.length).fill(null);let seed=0;for(let i=0;i<arr.length;i++){const v=arr[i];if(i<len-1){seed+=v}else if(i===len-1){seed+=v;out[i]=seed/len}else{out[i]=v*k+out[i-1]*(1-k)}}return out}
  function RSI_Wilder(closes,len=14){const rsi=Array(closes.length).fill(null);let ag=0,al=0;for(let i=1;i<closes.length;i++){const ch=closes[i]-closes[i-1];const g=ch>0?ch:0,l=ch<0?-ch:0;if(i<=len){ag+=g;al+=l;if(i===len){const rs=(al/len===0)?1e9:(ag/len)/(al/len);rsi[i]=100-(100/(1+rs))}}else{ag=(ag*(len-1)+g)/len;al=(al*(len-1)+l)/len;const rs=(al===0)?1e9:ag/al;rsi[i]=100-(100/(1+rs))}}return rsi}
  function MACD_EMA(c,f=12,s=26,sig=9){const ef=EMA(c,f),es=EMA(c,s);const macdLine=c.map((_,i)=>(ef[i]==null||es[i]==null)?null:ef[i]-es[i]);const seed=macdLine.map(v=>v==null?null:v);const firstIdx=seed.findIndex(v=>v!=null);let signalArr=Array(macdLine.length).fill(null);if(firstIdx>=0){const slice=seed.slice(firstIdx).map(v=>v??0);const emaSig=EMA(slice,sig);for(let i=0;i<emaSig.length;i++){signalArr[firstIdx+i]=(seed[firstIdx+i]==null)?null:emaSig[i]}}const hist=macdLine.map((v,i)=>(v==null||signalArr[i]==null)?null:(v-signalArr[i]));return{dif:macdLine,dea:signalArr,hist}}
  function TR(o,h,l,c){const out=Array(c.length).fill(null);for(let i=0;i<c.length;i++){if(i===0)out[i]=h[i]-l[i];else out[i]=Math.max(h[i]-l[i],Math.abs(h[i]-c[i-1]),Math.abs(l[i]-c[i-1]))}return out}
  function ATR(o,h,l,c,len=14){const tr=TR(o,h,l,c);const out=Array(c.length).fill(null);let seed=0;for(let i=0;i<tr.length;i++){const v=tr[i];if(i<len){seed+=v;if(i===len-1)out[i]=seed/len}else{out[i]=(out[i-1]*(len-1)+v)/len}}return out}

  // ---------- KLINES ----------  //
  async function fetchKlines(sym, interval, limit=1000){
    const url = `https://api.binance.com/api/v3/klines?symbol=${encodeURIComponent(sym)}&interval=${interval}&limit=${limit}`;
    const r = await fetch(url, {cache:'no-store'});
    if(!r.ok) throw new Error('HTTP '+r.status);
    const k = await r.json();
    return k.map(a=>({ open:+a[1], high:+a[2], low:+a[3], close:+a[4], tsStart:+a[0], tsEnd:+a[6], final:true }));
  }

  // ---------- WS ---------- //
  const wsHub = (()=>{
    const BASES=['wss://stream.binance.com:9443/stream','wss://data-stream.binance.vision/stream'];
    let host=0, ws=null, connected=false, backoff=2000, sendQ=[];
    const MAX_BACK=30000;

    const want = new Set();
    const listeners = new Map();
    const bySymbol = new Map();

    function url(){ return BASES[host%BASES.length]; }

    function ensureOpen(){
      if (ws && (ws.readyState===WebSocket.OPEN || ws.readyState===WebSocket.CONNECTING)) return;
      try{ ws && ws.close(); }catch{}
      ws = new WebSocket(url());
      ws.onopen = ()=>{
        connected=true;
        for (const m of sendQ){ try{ ws.send(JSON.stringify(m)); }catch{} }
        sendQ.length=0;
        if (want.size){ try{ ws.send(JSON.stringify({method:'SUBSCRIBE', params:[...want], id:Date.now()})); }catch{} }
        backoff=2000;
        status('WS connected');
      };
      ws.onclose = ()=>{
        connected=false; status('WS reconnecting…');
        host=(host+1)%BASES.length;
        setTimeout(ensureOpen, backoff + Math.floor(Math.random()*700));
        backoff=Math.min(Math.round(backoff*1.7), MAX_BACK);
      };
      ws.onerror = ()=>{};
      ws.onmessage = (ev)=>{
        let raw; try{ raw=JSON.parse(ev.data); }catch{ return; }
        if (Object.prototype.hasOwnProperty.call(raw,'result')) return;
        const stream=raw.stream||''; const data=raw.data||raw;
        if (!stream) return;
        const key = stream.toLowerCase();
        const set = listeners.get(key);
        if (!set || !set.size) return;
        for (const fn of set){ try{ fn(data); }catch{} }
      };
    }
    function send(msg){
      if (connected && ws && ws.readyState===WebSocket.OPEN){
        try{ ws.send(JSON.stringify(msg)); }catch{ sendQ.push(msg); }
      } else { sendQ.push(msg); ensureOpen(); }
    }
    function subscribe(sym, subKey, handler){
      const key = `${sym.toLowerCase()}@${subKey.toLowerCase()}`;
      if (!listeners.has(key)) listeners.set(key, new Set());
      listeners.get(key).add(handler);
      if (!want.has(key)){
        want.add(key);
        if (connected) send({method:'SUBSCRIBE', params:[key], id:Date.now()});
        else ensureOpen();
      }
      const SYM = sym.toUpperCase();
      if (!bySymbol.has(SYM)) bySymbol.set(SYM, new Set());
      bySymbol.get(SYM).add(key);
    }
    function unsubscribe(sym, subKey=null, handler=null){
      const SYM = sym.toUpperCase();
      const keys = bySymbol.get(SYM) || new Set();
      const targetKeys = subKey ? new Set([`${sym.toLowerCase()}@${subKey.toLowerCase()}`]) : new Set(keys);
      for (const key of targetKeys){
        if (handler && listeners.has(key)){ listeners.get(key).delete(handler); }
        if (listeners.has(key) && (!handler || listeners.get(key).size===0)){
          listeners.delete(key);
          if (want.has(key)){
            want.delete(key);
            if (connected) send({method:'UNSUBSCRIBE', params:[key], id:Date.now()});
          }
        }
        keys.delete(key);
      }
      if (!subKey) bySymbol.delete(SYM);
    }
    return { ensureOpen, subscribe, unsubscribe };
  })();

  // ---------- UI / Cards ---------- //
  function cardId(sym){ return `card_${sym}`; }
  function idsFor(sym){
    const U=sym.toUpperCase();
    return {
      headPrice:`head_price_${U}`, headInfo:`head_info_${U}`, status:`status_${U}`,
      tbody:`tbody_${U}`
    };
  }
  function ensureCard(sym){
    let card = document.getElementById(cardId(sym));
    const ids=idsFor(sym);
    if(!card){
      card = document.createElement('div'); card.className='card'; card.id=cardId(sym);
      card.innerHTML = `
        <div class="head">
          <span class="pill">${sym}</span>
          <span class="muted"></span>
          <span class="grow"></span>
          <span>Price: <span id="${ids.headPrice}" class="price">—</span></span>
          <span id="${ids.headInfo}" class="muted">Consensus: —</span>
          <button class="close" title="Close card">❌</button>
        </div>
        <div class="head-status"><span id="${ids.status}" class="status">Connecting…</span></div>
        <div style="overflow:auto">
          <table>
            <thead>
              <tr>
                <th>Timeframe</th>
                <th>Price (live)</th>
                <th>EMA7</th>
                <th>EMA20</th>
                <th>EMA50</th>
                <th>EMA200</th>
                <th>Price − EMA200 %</th>
                <th>Price − EMA50 %</th>
                <th>EMA50 slope</th>
                <th>RSI(14)</th>
                <th>RSI state</th>
                <th>DIF <span class="muted">(PC: MACD)</span></th>
                <th>DEA <span class="muted">(PC: Signal)</span></th>
                <th>MACD <span class="muted">(PC: Histogram)</span></th>
                <th>MACD (DIF) / Signal (DEA) cross</th>
                <th>ATR(14)</th>
                <th>Trend</th>
                <th>EMA-stack</th>
                <th>Stack pont</th>
                <th>Signal</th>
                <th>Last</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="${ids.tbody}"></tbody>
          </table>
        </div>
      `;
      boards.appendChild(card);
      card.querySelector('.close').addEventListener('click', ()=> removeCard(sym));
    }
    return card;
  }
  function setStatus(sym, txt){ const ids=idsFor(sym); const s=el(ids.status); if(s) s.textContent=txt; }
  function setHeadPrice(sym, n){ const ids=idsFor(sym); const p=el(ids.headPrice); if(p) p.textContent=n; }
  function setHeadInfo(sym, txt){ const ids=idsFor(sym); const i=el(ids.headInfo); if(i) i.textContent=txt; }

  // ---------- Consensus ---------- //
  function updateConsensus(sym){
    const body = el(idsFor(sym).tbody);
    if(!body) return;
    let buy=0, sell=0, total=0;
    body.querySelectorAll('tr').forEach(tr=>{
      total++; const k=tr.dataset.signal||'NEUTRAL';
      if (k==='BUY') buy++; else if (k==='SELL') sell++;
    });
    setHeadInfo(sym, `Consensus: BUY ${buy} / SELL ${sell} (össz: ${total})`);
  }

  // ---------- Rows ---------- //
  function rowKey(sym, interval){ return `${sym}__${interval}`; }
  function upsertRow(sym, interval){
    ensureCard(sym);
    const body = el(idsFor(sym).tbody);
    const key = rowKey(sym, interval);
    let tr = body.querySelector(`tr[data-key="${key}"]`);
    if(!tr){
      tr = document.createElement('tr'); tr.dataset.key=key; tr.dataset.signal='NEUTRAL';
      tr.innerHTML = `
        <td class="ival">${interval}</td>
        <td class="price">—</td>
        <td class="ema7">—</td>
        <td class="ema20">—</td>
        <td class="ema50">—</td>
        <td class="ema200">—</td>
        <td class="dist200">—</td>
        <td class="dist50">—</td>
        <td class="slope50">—</td>
        <td class="rsi">—</td>
        <td class="rsiState"><span class="badge neutral">Neutral</span></td>
        <td class="dif">—</td>
        <td class="dea">—</td>
        <td class="macd">—</td>
        <td class="macdcross"><span class="badge neutral">No cross</span></td>
        <td class="atr">—</td>
        <td class="trend"><span class="badge neutral">Neutral</span></td>
        <td class="stack"><span class="badge neutral">Neutral</span></td>
        <td class="score"><span class="heat">0</span></td>
        <td class="signal"><span class="badge neutral">Neutral</span></td>
        <td class="ts muted">—</td>
        <td><button class="rm">Remove</button></td>
      `;
      body.appendChild(tr);
      tr.querySelector('.rm').addEventListener('click', ()=>{
        const item=state.list.find(x=>x.sym===sym);
        if(item){
          item.intervals=item.intervals.filter(iv=>iv!==interval);
          if(item.intervals.length===0) removeCard(sym); else saveState();
        }
        tr.remove(); updateConsensus(sym);
      });
      const cached = taCache[taKey(sym, interval)];
      if (cached){ const d=ensureSym(sym); d.ema.set(interval,{...cached,e50prev:null,prevScore:null}); renderRow(sym, interval); }
    }
    return tr;
  }

  // ---------- Badges ---------- //
  function trendBadge(price,e50,e200){
    if (![price,e50,e200].every(Number.isFinite)) return `<span class="badge neutral">Neutral</span>`;
    if (price>e200 && e50>e200) return `<span class="badge bull">Bull</span>`;
    if (price<e200 && e50<e200) return `<span class="badge bear">Bear</span>`;
    return `<span class="badge neutral">Neutral</span>`;
  }
  function stackBadge(price,e7,e20,e50,e200){
    if (![price,e7,e20,e50,e200].every(Number.isFinite)) return `<span class="badge neutral">Neutral</span>`;
    const bull=(e7>e20 && e20>e50 && e50>e200 && price>e7);
    const bear=(e7<e20 && e20<e50 && e50<e200 && price<e7);
    if (bull) return `<span class="badge bull">Strong bull</span>`;
    if (bear) return `<span class="badge bear">Strong bear</span>`;
    return `<span class="badge neutral">Neutral</span>`;
  }
  function slopeArrow(prev,now){ if(!Number.isFinite(prev)||!Number.isFinite(now)) return '—'; if(now>prev) return '↗︎'; if(now<prev) return '↘︎'; return '→'; }
  function stackStrength(price,e7,e20,e50,e200){
    if (![price,e7,e20,e50,e200].every(Number.isFinite)) return 0;
    let s=0; s+=(e7>e20)?1:(e7<e20?-1:0); s+=(e20>e50)?1:(e20<e50?-1:0);
    s+=(e50>e200)?1:(e50<e200?-1:0); s+=(price>e7)?1:(price<e7?-1:0);
    return s;
  }
  const ATR_MULT=0.3;
  function rsiBadge(r){ if(!Number.isFinite(r)) return `<span class="badge neutral">Neutral</span>`; if(r>=70) return `<span class="badge bear">Overbought</span>`; if(r<=30) return `<span class="badge bull">Oversold</span>`; return `<span class="badge neutral">Neutral</span>`; }
  function macdCrossBadge(dif,dea){ if(!Number.isFinite(dif)||!Number.isFinite(dea)) return `<span class="badge neutral">No cross</span>`; if(dif>dea) return `<span class="badge bull">Bull cross</span>`; if(dif<dea) return `<span class="badge bear">Bear cross</span>`; return `<span class="badge neutral">No cross</span>`; }
  function scoreHeatStyle(score){ const m=Math.min(4,Math.max(0,Math.abs(score)))/4, a=0.12+m*0.28, rgb=score>=0?'34,197,94':'239,68,68', col=score>=0?'#34d399':'#f87171'; return `background:rgba(${rgb},${a});color:${col}`; }
  function signalBadge(score, slopeChar, price, e50, e200, prevScore, atr){
    let txt='Neutral', cls='neutral', warn=false;
    const up=slopeChar==='↗︎', dn=slopeChar==='↘︎';
    const atrOk = Number.isFinite(atr)&&Number.isFinite(price)&&Number.isFinite(e50) ? Math.abs(price-e50)>=ATR_MULT*atr : true;
    if (score>=3 && up && Number.isFinite(price)&&Number.isFinite(e200)&&price>e200 && atrOk){ txt='BUY'; cls='bull'; }
    else if (score<=-3 && dn && Number.isFinite(price)&&Number.isFinite(e200)&&price<e200 && atrOk){ txt='SELL'; cls='bear'; }
    else if (Math.abs(score)===2){ txt='Watch'; cls='neutral'; }
    if (Number.isFinite(prevScore)){
      if ((prevScore>0&&score<0)||(prevScore<0&&score>0)) warn=true;
      else if (Math.abs(prevScore)>=3 && Math.abs(score)<3) warn=true;
    }
    return { html:`<span class="badge ${cls}">${txt}</span>`, kind:txt.toUpperCase() };
  }

  // ---------- Cache ---------- //
  function computeFromCache(sym, iv, force=false){
    const d=ensureSym(sym);
    const arr=d.kCache.get(iv)||[];
    if (!arr.length) return;
    const closed=arr.filter(x=>x&&x.final===true).length;
    if (!force && closed<MIN_BARS_FOR_STABLE) return;

    const o=arr.map(x=>x.open), h=arr.map(x=>x.high), l=arr.map(x=>x.low), c=arr.map(x=>x.close);
    const e7=EMA(c,7), e20=EMA(c,20), e50=EMA(c,50), e200=EMA(c,200);
    const rsiA=RSI_Wilder(c,14); const {dif,dea,hist}=MACD_EMA(c,12,26,9); const atrA=ATR(o,h,l,c,14);
    const prev = d.ema.get(iv);
    const rec = {
      e7:e7.at(-1), e20:e20.at(-1), e50:e50.at(-1), e200:e200.at(-1),
      e50prev:e50.at(-2)??null,
      rsi:rsiA.at(-1), dif:dif.at(-1), dea:dea.at(-1), macd:hist.at(-1),
      atr:atrA.at(-1), ts: Date.now(), prevScore: prev ? prev.prevScore : null
    };
    d.ema.set(iv, rec); saveTaRec(sym, iv, rec);
    renderRow(sym, iv);
  }

  // ---------- EMA refresh ---------- //
  async function refreshEMA(sym, iv){
    const d=ensureSym(sym);
    try{
      const arr=d.kCache.get(iv)||[];
      const closed=arr.filter(x=>x&&x.final===true).length;
      if (closed>=MIN_BARS_FOR_STABLE){ computeFromCache(sym, iv); return; }
      const kl=await fetchKlines(sym, iv, 1000);
      d.kCache.set(iv, kl.slice(-1000));
      computeFromCache(sym, iv, true);
    }catch(e){
      d.ema.set(iv,{e7:null,e20:null,e50:null,e200:null,e50prev:null,rsi:null,dif:null,dea:null,macd:null,atr:null,ts:Date.now(),err:true,prevScore:null});
      renderRow(sym, iv, 'Indicator error');
    }
  }

  // ---------- Price ---------- //
  let pageHidden=false;
  document.addEventListener('visibilitychange', ()=>{ pageHidden=document.hidden; });
  function schedulePricePaint(sym){
    if (pageHidden) return;
    const d=ensureSym(sym); const now=performance.now();
    if (now - d.pricePaintTs < 1000/Math.max(1,MAX_FPS)) return;
    if (d.raf) return;
    d.pricePaintTs=now; d.raf=true;
    requestAnimationFrame(()=>{ d.raf=false; const item=state.list.find(x=>x.sym===sym); if(!item) return; for(const iv of item.intervals) updateLivePrice(sym, iv); updateConsensus(sym); });
  }

  // ---------- Renderers ---------- //
  function updateLivePrice(sym, iv){
    const tr=upsertRow(sym, iv);
    const d=ensureSym(sym); const rec=d.ema.get(iv)||{e7:null,e20:null,e50:null,e200:null,e50prev:null,rsi:null,dif:null,dea:null,macd:null,atr:null,ts:null,prevScore:null};
    if(Number.isFinite(d.lastPrice)){
      const pos=Number.isFinite(rec.e200)&&d.lastPrice>=rec.e200;
      tr.querySelector('.price').innerHTML = pos? `<span class="green">${fmtPx(sym,d.lastPrice)}</span>` : `<span class="red">${fmtPx(sym,d.lastPrice)}</span>`;
      setHeadPrice(sym, fmtPx(sym,d.lastPrice));
    } else { tr.querySelector('.price').textContent='—'; }

    if(Number.isFinite(d.lastPrice)&&Number.isFinite(rec.e200)&&rec.e200!==0){
      const pct200=(d.lastPrice/rec.e200-1)*100; tr.querySelector('.dist200').innerHTML=pct200>=0?`<span class="green">${fmtPct(pct200)}</span>`:`<span class="red">${fmtPct(pct200)}</span>`;
    } else tr.querySelector('.dist200').textContent='—';

    if(Number.isFinite(d.lastPrice)&&Number.isFinite(rec.e50)&&rec.e50!==0){
      const pct50=(d.lastPrice/rec.e50-1)*100; tr.querySelector('.dist50').innerHTML=pct50>=0?`<span class="green">${fmtPct(pct50)}</span>`:`<span class="red">${fmtPct(pct50)}</span>`;
    } else tr.querySelector('.dist50').textContent='—';

    tr.querySelector('.trend').innerHTML = trendBadge(d.lastPrice, rec.e50, rec.e200);
    const score = stackStrength(d.lastPrice, rec.e7, rec.e20, rec.e50, rec.e200);
    const prevScore = rec.prevScore;
    tr.querySelector('.slope50').textContent = slopeArrow(rec.e50prev, rec.e50);
    const sig = signalBadge(score, tr.querySelector('.slope50').textContent, d.lastPrice, rec.e50, rec.e200, prevScore, rec.atr);
    tr.querySelector('.signal').innerHTML=sig.html; tr.dataset.signal=sig.kind;
    const heat=tr.querySelector('.score .heat'); heat.textContent=score>0?('+'+score):String(score); heat.setAttribute('style', scoreHeatStyle(score));
    if (Number.isFinite(rec.rsi)){ const cls=rec.rsi>=70?'rsi-ob':(rec.rsi<=30?'rsi-os':''); tr.querySelector('.rsi').innerHTML=`<span class="${cls}">${fmtN(rec.rsi,2)}</span>`; tr.querySelector('.rsiState').innerHTML=rsiBadge(rec.rsi); }
    else { tr.querySelector('.rsi').textContent='—'; tr.querySelector('.rsiState').innerHTML=`<span class="badge neutral">Neutral</span>`; }
    tr.querySelector('.dif').innerHTML=Number.isFinite(rec.dif)?`<span title="DIF = TradingView: MACD (vonal)">${fmtN(rec.dif,6)}</span>`:'—';
    tr.querySelector('.dea').innerHTML=Number.isFinite(rec.dea)?`<span title="DEA = TradingView: Signal (jelvonal)">${fmtN(rec.dea,6)}</span>`:'—';
    tr.querySelector('.macd').innerHTML=Number.isFinite(rec.macd)?(rec.macd>=0?`<span class="green" title="MACD (hisztogram)">${fmtN(rec.macd,6)}</span>`:`<span class="red" title="MACD (hisztogram)">${fmtN(rec.macd,6)}</span>`):'—';
    tr.querySelector('.macdcross').innerHTML=macdCrossBadge(rec.dif, rec.dea);
    if (Number.isFinite(rec.atr)&&Number.isFinite(d.lastPrice)&&d.lastPrice!==0){ const atrPct=(rec.atr/d.lastPrice)*100; tr.querySelector('.atr').innerHTML=`<span title="ATR%: ${atrPct.toFixed(2)}%">${fmtN(rec.atr,6)}</span>`; }
    else tr.querySelector('.atr').textContent=Number.isFinite(rec.atr)?fmtN(rec.atr,6):'—';

    let alertNow=false; if (Number.isFinite(prevScore)){ if ((prevScore>0&&score<0)||(prevScore<0&&score>0)) alertNow=true; else if (Math.abs(prevScore)>=3&&Math.abs(score)<3) alertNow=true; }
    tr.classList.toggle('alert', alertNow);
    rec.prevScore=score; ensureSym(sym).ema.set(iv, rec);
    tr.querySelector('.ts').textContent = rec.ts || ensureSym(sym).lastTs ? htime(rec.ts || ensureSym(sym).lastTs) : '—';
  }

  function renderRow(sym, iv, err){
    const tr=upsertRow(sym, iv);
    const d=ensureSym(sym);
    const rec=d.ema.get(iv)||{e7:null,e20:null,e50:null,e200:null,e50prev:null,rsi:null,dif:null,dea:null,macd:null,atr:null,ts:null,prevScore:null};
    tr.querySelector('.ema7').textContent=fmtN(rec.e7);
    tr.querySelector('.ema20').textContent=fmtN(rec.e20);
    tr.querySelector('.ema50').textContent=fmtN(rec.e50);
    tr.querySelector('.ema200').textContent=fmtN(rec.e200);
    tr.querySelector('.slope50').textContent=slopeArrow(rec.e50prev, rec.e50);
    tr.querySelector('.ts').textContent = err ? err : (rec.ts ? htime(rec.ts) : '—');
    updateLivePrice(sym, iv); updateConsensus(sym);
  }

  // ---------- SUBSCRIBE ---------- //
  function subscribePrice(sym){
    let first=false;
    wsHub.subscribe(sym, 'trade', (t)=>{
      const price=parseFloat(t.p), time=t.T ?? t.E ?? Date.now();
      if (!Number.isFinite(price)) return;
      const d=ensureSym(sym); d.lastPrice=price; d.lastTs=time;
      if (!first){ first=true; setStatus(sym, 'Live'); }
      schedulePricePaint(sym);
    });
  }
  function subscribeKlines(sym, iv){
    wsHub.subscribe(sym, `kline_${iv}`, (msg)=>{
      const k=msg?.k; if(!k) return;
      const d=ensureSym(sym);
      const rec={open:+k.o, high:+k.h, low:+k.l, close:+k.c, tsStart:+k.t, tsEnd:+k.T, final:!!k.x};
      const arr=d.kCache.get(iv)||[];
      const last=arr[arr.length-1];
      if (last && last.tsStart===rec.tsStart) arr[arr.length-1]=rec; else { arr.push(rec); if (arr.length>1000) arr.splice(0,arr.length-1000); }
      d.kCache.set(iv, arr);

      const now=Date.now(); const lastCalc=d.lastCalcTs.get(iv)||0;
      if (rec.final || (now-lastCalc)>=COMPUTE_THROTTLE_MS){ computeFromCache(sym, iv, rec.final); d.lastCalcTs.set(iv, now); }
    });
  }

  // ---------- Add symbols ---------- //
  function addSymbols(list, intervals){
    const ivs = intervals.length ? intervals.filter(v=>ALL_INTS.includes(v)) : loadDefaultIntervals();
    if (!ivs.length){ alert('Select at least one timeframe.'); return; }

    const existingSyms = new Set(state.list.map(x=>x.sym));
    const incoming = list.map(s=>s.toUpperCase().trim()).filter(s=>/^[A-Z0-9]{6,}$/.test(s));
    const newOnes = incoming.filter(s=>!existingSyms.has(s));
    let remaining = 4 - state.list.length;
    if (remaining<=0){ alert('You’ve reached the 4-card limit. Close a card to add a new one.'); return; }
    const toOpen = newOnes.slice(0, remaining);
    const skipped = newOnes.slice(remaining);

    for(const sym of toOpen){
      ensureCard(sym); setStatus(sym,'Connecting…');
      state.list.push({sym, intervals:[...ivs]});
      ensureSym(sym);
      subscribePrice(sym);
      for (const iv of ivs){ upsertRow(sym, iv); subscribeKlines(sym, iv); refreshEMA(sym, iv); }
    }
    saveState();
    if (skipped.length) alert('Skipped due to the 4-card limit: '+skipped.join(', '));
  }

  // ---------- Remove card ---------- //
  function removeCard(sym){
    wsHub.unsubscribe(sym);
    state.list = state.list.filter(x=>x.sym!==sym);
    saveState();
    const c=document.getElementById(cardId(sym)); if (c) c.remove();
    symData.delete(sym);
  }

  // ---------- Refresh ---------- //
  let isRefreshing=false;
  async function refreshAllEMA(){
    if (isRefreshing) return;
    isRefreshing=true; refreshBtn.disabled=true;
    try{
      status('EMA/RSI/MACD/ATR refresh…');
      for(const item of state.list){
        await Promise.allSettled(item.intervals.map(iv=>refreshEMA(item.sym, iv)));
        await sleep(60);
      }
      status('Done.');
    }finally{ isRefreshing=false; refreshBtn.disabled=false; }
  }
  let autoTimer=null;
  function startAuto(){ stopAuto(); if (!state.auto) return; autoTimer=setInterval(refreshAllEMA, state.period*1000); }
  function stopAuto(){ if (autoTimer){ clearInterval(autoTimer); autoTimer=null; } }
  const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));

  // ---------- Events ---------- //
  addBtn.addEventListener('click', ()=>{
    const raw=symInput.value.trim(); const syms=raw?raw.split(/[\s,;]+/).map(s=>s.trim()).filter(Boolean):[];
    const chosen=CHECKS.filter(x=>x.checked).map(x=>x.value);
    if(!syms.length){ alert('Enter at least one symbol.'); return; }
    addSymbols(syms, chosen);
    symInput.value='';
  });
  refreshBtn.addEventListener('click', refreshAllEMA);

  // ---------- Settings ---------- //
  btnSettings.addEventListener('click', ()=>{
    defPairsEl.value = loadDefaultPairs().join(', ');
    defPeriodEl.value= String(loadDefaultPeriod());
    const set = new Set(loadDefaultIntervals());
    defIntervalsWrap.querySelectorAll('input[type="checkbox"]').forEach(ch=> ch.checked=set.has(ch.value));
    const adv=loadAdv(); defThrottleMsEl.value=String(adv.throttleMs); defMinBarsEl.value=String(adv.minBars); defMaxFpsEl.value=String(adv.maxFps);
    drawer.classList.add('open');
  });
  btnCloseSettings.addEventListener('click', ()=> drawer.classList.remove('open'));
  btnSaveDefaults.addEventListener('click', ()=>{
    let pairs=defPairsEl.value.split(/[\s,;]+/).map(s=>s.trim().toUpperCase()).filter(Boolean);
    pairs=Array.from(new Set(pairs)).slice(0,4);
    const ivs = Array.from(defIntervalsWrap.querySelectorAll('input[type="checkbox"]')).filter(ch=>ch.checked).map(ch=>ch.value).filter(v=>ALL_INTS.includes(v));
    const per = Math.max(5, Math.min(600, parseInt(defPeriodEl.value||DEFAULT_PERIOD,10)));
    const adv = {
      throttleMs: Math.max(200, Math.min(10000, parseInt(defThrottleMsEl.value||DEFAULT_ADV.throttleMs,10))),
      minBars:    Math.max(100, Math.min(1000, parseInt(defMinBarsEl.value||DEFAULT_ADV.minBars,10))),
      maxFps:     Math.max(1,   Math.min(60,   parseInt(defMaxFpsEl.value||DEFAULT_ADV.maxFps,10)))
    };
    try{
      localStorage.setItem(LS_DEF_PAIRS, JSON.stringify(pairs.length?pairs:DEFAULT_PAIRS.slice(0,4)));
      localStorage.setItem(LS_DEF_INTS,  JSON.stringify(ivs.length?ivs:DEFAULT_INTS));
      localStorage.setItem(LS_DEF_PER,   String(per));
      saveAdv(adv);
    }catch{}
    drawer.classList.remove('open');
  });
  btnApplyDefaults.addEventListener('click', ()=>{
    let pairs=defPairsEl.value.split(/[\s,;]+/).map(s=>s.trim().toUpperCase()).filter(Boolean);
    pairs=Array.from(new Set(pairs)).slice(0,4);
    if (!pairs.length) pairs=DEFAULT_PAIRS.slice(0,4);
    const ivs = Array.from(defIntervalsWrap.querySelectorAll('input[type="checkbox"]')).filter(ch=>ch.checked).map(ch=>ch.value).filter(v=>ALL_INTS.includes(v));
    const per = Math.max(5, Math.min(600, parseInt(defPeriodEl.value||DEFAULT_PERIOD,10)));
    const adv = {
      throttleMs: Math.max(200, Math.min(10000, parseInt(defThrottleMsEl.value||DEFAULT_ADV.throttleMs,10))),
      minBars:    Math.max(100, Math.min(1000, parseInt(defMinBarsEl.value||DEFAULT_ADV.minBars,10))),
      maxFps:     Math.max(1,   Math.min(60,   parseInt(defMaxFpsEl.value||DEFAULT_ADV.maxFps,10)))
    };
    try{
      localStorage.setItem(LS_DEF_PAIRS, JSON.stringify(pairs));
      localStorage.setItem(LS_DEF_INTS,  JSON.stringify(ivs.length?ivs:DEFAULT_INTS));
      localStorage.setItem(LS_DEF_PER,   String(per));
      saveAdv(adv);
    }catch{}

    COMPUTE_THROTTLE_MS=adv.throttleMs; MIN_BARS_FOR_STABLE=adv.minBars; MAX_FPS=adv.maxFps;

    for (const item of state.list) wsHub.unsubscribe(item.sym);
    boards.innerHTML=''; symData.clear();

    state.list = pairs.map(sym=>({sym, intervals:[...(ivs.length?ivs:DEFAULT_INTS)]}));
    state.list = state.list.slice(0,4);
    state.period = per; saveState();

    wsHub.ensureOpen();
    for (const item of state.list){
      ensureCard(item.sym); setStatus(item.sym,'Connecting…');
      ensureSym(item.sym); subscribePrice(item.sym);
      for (const iv of item.intervals){ upsertRow(item.sym, iv); subscribeKlines(item.sym, iv); refreshEMA(item.sym, iv); }
    }
    refreshAllEMA();
    if (state.auto) startAuto();

    drawer.classList.remove('open');
  });

  btnHelp.addEventListener('click', ()=> helpDrawer.classList.add('open'));
  btnCloseHelp.addEventListener('click', ()=> helpDrawer.classList.remove('open'));

  // ---------- INIT ---------- //
  wsHub.ensureOpen();
  (function init(){
    const syms = new Set();
    for (const item of state.list){
      ensureCard(item.sym); setStatus(item.sym,'Connecting…'); ensureSym(item.sym);
      subscribePrice(item.sym);
      for (const iv of item.intervals){ upsertRow(item.sym, iv); subscribeKlines(item.sym, iv); }
      syms.add(item.sym);
    }
    for (const item of state.list){ for (const iv of item.intervals) refreshEMA(item.sym, iv); }
    refreshAllEMA();
    if (state.auto) startAuto();
  })();

  window.addEventListener('beforeunload', ()=>{
    for (const item of state.list) wsHub.unsubscribe(item.sym);
  });

  function status(txt){ statusEl.textContent = txt; }

})();
</script>
</body>
</html>
