<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Taker Buy vs Sell Volume – Live (Binance)</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<style>
  :root{--bg:#0b1220;--panel:#0f172a;--fg:#e6edf3;--muted:#9aa4b2;--line:#1e293b;--ok:#34d399;--warn:#fbbf24;--err:#f87171}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px system-ui,Segoe UI,Roboto,Ubuntu,Inter,Arial}
  header{display:flex;flex-wrap:wrap;gap:10px;align-items:center;padding:12px 14px;border-bottom:1px solid var(--line);background:linear-gradient(180deg,#0b1220,#0e1626)}
  header h1{font-size:16px;margin:0 8px 0 0;color:#cbd5e1}
  input,select,button,label{color:var(--fg)}
  input,select,button{background:#0f1a2b;border:1px solid #233552;border-radius:10px;padding:8px 10px}
  input::placeholder{color:#8aa0b6}
  button{cursor:pointer;transition:.15s}
  button:hover{filter:brightness(1.08)}
  .muted{color:var(--muted);font-size:12px}
  main{padding:14px}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(360px,1fr));gap:12px}
  .card{background:var(--panel);border:1px solid var(--line);border-radius:14px;overflow:hidden;display:flex;flex-direction:column;min-width:0}
  .card .head{border-bottom:1px solid var(--line);padding:10px 12px}
  .card .head-top{display:grid;grid-template-columns:auto 1fr auto auto; /* pill | grow | price | close */gap:8px;align-items:center;}
  .pill{font-weight:700;letter-spacing:.3px;border-radius:999px;padding:4px 10px;background:#0e1a2e;border:1px solid #223552}
  .grow{flex:1}
  .price{font-weight:700}
  .close{background:#1a243b;border:1px solid #2b3759;border-radius:8px;padding:4px 8px;cursor:pointer}
  .card .head-bottom{margin-top:6px;min-height:18px;display:flex;justify-content:center;align-items:center}
  .status{font-size:12px;color:var(--muted)}
  .stats{display:grid;grid-template-columns:1fr 1fr;gap:8px;padding:10px 12px}
  .stat{background:#0c1424;border:1px solid #22324a;border-radius:12px;padding:10px}
  .stat h3{margin:0 0 6px;font-size:12px;color:#94a3b8}
  .stat .val{font-size:18px;font-variant-numeric:tabular-nums}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center;padding:8px 12px;border-top:1px dashed #192238;border-bottom:1px dashed #192238;background:#0d1628}
  .controls label{display:flex;gap:6px;align-items:center}
  .charts{display:flex;flex-direction:column;gap:10px;padding:10px 12px}
  .chart-wrap{position:relative;width:100%}
  .chart-wrap.vol{min-height:300px}
  .chart-wrap.quote{min-height:220px}
  .chart-wrap.count{min-height:220px}
  .chart-wrap.cvd{min-height:180px}
  canvas{position:absolute;inset:0;width:100%!important;height:100%!important}
  .drawer{position:fixed;right:16px;top:72px;width:460px;max-width:95vw;max-height:86vh;overflow:auto;background:var(--panel);border:1px solid #1b2336;border-radius:12px;box-shadow:0 10px 40px rgba(0,0,0,.5);padding:12px;display:none;z-index:50}
  .drawer.open{display:block}
  .drawer h3{margin:4px 0 10px}
  .row{display:flex;gap:8px;align-items:center;margin:8px 0}
  .row label{flex:1}
  .row textarea{flex:1}
  .btns{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}
  .drawer ul{margin:6px 0 6px 18px}
</style>
</head>
<body>
  <header>
    <h1>Taker Buy vs Sell Volume – Live (Binance)</h1>
    <label>Pairs (comma-separated):
      <input id="symbols" placeholder="e.g. BTCUSDC,ETHUSDC,BNBUSDC,SOLUSDC" style="min-width:320px">
    </label>
    <button id="addBtn">Add</button>
    <button id="clearBtn">Close all cards</button>
    <button id="btnSettings">⚙️ Settings</button>
    <button id="btnHelp">❓ Help</button>
    <span class="muted">Source: <strong>Binance Spot (@trade)</strong></span>
  </header>

  <main>
    <div id="grid" class="grid"></div>
  </main>

  <div id="settings" class="drawer">
    <h3>Defaults</h3>
    <div class="row">
      <label for="defPairs">Default pairs (comma-separated):</label>
      <textarea id="defPairs" rows="3" placeholder="e.g. BTCUSDC,ETHUSDC,BNBUSDC,SOLUSDC"></textarea>
    </div>

    <div class="row">
      <label for="defBucket">Default time window:</label>
      <select id="defBucket">
        <option value="5">5s</option><option value="10">10s</option><option value="15">15s</option>
        <option value="30">30s</option><option value="60">1m</option><option value="120">2m</option>
        <option value="300">5m</option><option value="900">15m</option>
      </select>
    </div>
    <div class="row">
      <label for="defBars">Default number of bars:</label>
      <select id="defBars">
        <option>30</option><option>60</option><option>120</option><option>240</option>
      </select>
    </div>

    <small class="muted">“Save + apply now” azonnal megnyitja a (max 4) default párokat, deduplikálva.</small>
    <div class="btns">
      <button id="btnSaveDefaults">Save</button>
      <button id="btnApplyDefaults">Save + apply now</button>
      <button id="btnCloseSettings">Close</button>
    </div>
  </div>

  <div id="help" class="drawer" aria-label="Help">
     <h2>User Guide</h2>
<h3>What is this?</h3>
<p>
  <b>Taker Buy vs Sell Volume – Live (Binance)</b> shows who is more aggressive <i>right now</i> on Binance Spot: buyers (green) or sellers (red). You can open up to four symbols as separate cards and watch their live flow side by side. <!-- :contentReference[oaicite:0]{index=0} -->
</p>

<h3>Quick start</h3>
<ol>
  <li>Type symbols in <b>Pairs</b> (comma or space separated), e.g. <code>BTCUSDC, ETHUSDC</code>, then click <b>Add</b>. (Max <b>4</b> cards at once.)</li>
  <li>On each card pick a <b>Time window</b> (5s…15m) and how many <b>Bars</b> to show (30–240).</li>
  <li>Use <b>Close all cards</b> to clear the screen. Save your defaults in <b>Settings</b>, or hit <i>Save + apply now</i> to reopen them instantly.</li>
</ol>

<h3>What’s on each card?</h3>
<ul>
  <li><b>Header</b>: symbol pill, live <b>Price</b>, close button, and a status line (<i>Connecting… / Backfill… / Live</i>).</li>
  <li><b>Stats row</b> (updates every bucket):
    <ul>
      <li><b>Current price</b></li>
      <li><b>Active candle start</b> &amp; <b>length</b> (your selected window)</li>
      <li><b>Taker Buy</b>, <b>Taker Sell</b>, and <b>Net (Buy − Sell)</b> for the active bucket
      </li>
    </ul>
  </li>
  <li><b>Controls</b>: <b>Time window</b> (bucket size) and <b>Bars</b> (history depth). Changing these reloads the series for that card.</li>
  <li><b>Charts</b>:
    <ol>
      <li><b>Volume (quantity)</b> — green = taker buys, red = taker sells (base-asset units)</li>
      <li><b>Volume (quote)</b> — same idea, but in notional value (price × quantity)</li>
      <li><b>Trades (count)</b> — number of buy-side vs sell-side trades</li>
      <li><b>CVD</b> (Cumulative Volume Delta) — running total of (buy − sell) volume over time
      </li>
    </ol>
  </li>
</ul>

<h3>How to read it (quick)</h3>
<ul>
  <li><b>Who’s in control?</b> If <i>Net (Buy−Sell)</i> stays above zero and <i>CVD</i> rises over several bars, buyers dominate. Below zero with falling CVD ⇒ sellers dominate. </li>
  <li><b>Don’t judge one spike.</b> Look for a consistent direction over the last 3–5 bars.</li>
  <li><b>Divergence = caution.</b> New price high but flat/falling CVD can signal absorption; flat price with rising CVD can hint at accumulation.</li>
  <li><b>Adjust the window.</b> Smaller windows = more detail (and noise). Larger windows = smoother trend. </li>
</ul>

<h3>Good habits</h3>
<ul>
  <li>Watch <b>Net</b> and <b>CVD</b> together: they tell you if the current push is being sustained.</li>
  <li>Compare <b>quantity</b> vs <b>quote</b> volume: if quote spikes harder than quantity, the same flow happens at higher prices.</li>
  <li>Use a <b>short</b> window (5–15s) for scalping flow; switch to <b>1–5m</b> to see the bigger push without noise.</li>
</ul>

<h3>Tips & troubleshooting</h3>
<ul>
  <li><b>Just opened?</b> Status shows <i>Backfill…</i> briefly while it loads recent history; it turns <i>Live</i> once ready.</li>
  <li><b>No space for new symbols?</b> The app allows up to four cards. Close one to add another.</li>
  <li><b>Data hiccup?</b> Change the window or Bars once to force a quick reload, or close/re-add the card.</li>
</ul>

    <div class="btns"><button id="btnCloseHelp">Close</button></div>
  </div>

<script>
(() => {
  // ---- Chart.js ---- //
  if (window.Chart && Chart.defaults) {
    Chart.defaults.animation = false;
    Chart.defaults.responsive = true;
    Chart.defaults.maintainAspectRatio = false;
  }

  // ---- DOM ---- //
  const grid = document.getElementById('grid');
  const symbolsInput = document.getElementById('symbols');
  const addBtn = document.getElementById('addBtn');
  const clearBtn = document.getElementById('clearBtn');
  const drawer = document.getElementById('settings');
  const btnSettings = document.getElementById('btnSettings');
  const btnSaveDefaults = document.getElementById('btnSaveDefaults');
  const btnApplyDefaults = document.getElementById('btnApplyDefaults');
  const btnCloseSettings = document.getElementById('btnCloseSettings');
  const defPairsEl = document.getElementById('defPairs');
  const defBucketEl = document.getElementById('defBucket');
  const defBarsEl   = document.getElementById('defBars');
  const helpDrawer = document.getElementById('help');
  const btnHelp = document.getElementById('btnHelp');
  const btnCloseHelp = document.getElementById('btnCloseHelp');

  // ---- Storage keys ---- //
  const LS = {
    list:'tbsv_ms_list',
    lastInput:'tbsv_ms_last_input',
    defPairs:'tbsv_ms_def_pairs',
    defBucket:'tbsv_ms_def_bucket',
    defBars:'tbsv_ms_def_bars'
  };
  const DEFAULT_PAIRS = ['BTCUSDC','ETHUSDC','BNBUSDC','SOLUSDC'];

  // ---- Helpers ---- //
  function parsePairs(txt){
    return String(txt||'').split(/[\s,;]+/)
      .map(s=>s.trim().toUpperCase())
      .filter(s=>/^[A-Z0-9]{6,}$/.test(s));
  }
  function loadUserDefaults(){
    try{
      const j = JSON.parse(localStorage.getItem(LS.defPairs)||'null');
      if (Array.isArray(j) && j.length) return j.map(s=>String(s).toUpperCase().trim()).filter(Boolean);
    }catch{}
    return DEFAULT_PAIRS.slice();
  }
  function loadDefaultBucket(){
    const v = parseInt(localStorage.getItem(LS.defBucket)||'60',10);
    return [5,10,15,30,60,120,300,900].includes(v) ? v : 60;
  }
  function loadDefaultBars(){
    const v = parseInt(localStorage.getItem(LS.defBars)||'60',10);
    return [30,60,120,240].includes(v) ? v : 60;
  }
  function loadList(){
    try{
      const j = JSON.parse(localStorage.getItem(LS.list)||'null');
      if (Array.isArray(j) && j.length) return j.slice(0,4);
    }catch{}
    return loadUserDefaults().slice(0,4);
  }
  function saveList(){ try{ localStorage.setItem(LS.list, JSON.stringify(Array.from(active.keys()))); }catch{} }

  // ---- Exchange Info ---- //
  async function fetchExchangeInfo(sym){
    const ctrl=new AbortController(); const t=setTimeout(()=>ctrl.abort(),5000);
    try{
      const r=await fetch(`https://api.binance.com/api/v3/exchangeInfo?symbol=${encodeURIComponent(sym)}`,{cache:'no-store',signal:ctrl.signal});
      if(!r.ok) return null;
      const j=await r.json(); const s=(j.symbols&&j.symbols[0])||null; if(!s) return null;
      const pf=(s.filters||[]).find(f=>f.filterType==='PRICE_FILTER');
      const lf=(s.filters||[]).find(f=>f.filterType==='LOT_SIZE');
      let priceDecimals=8;
      if (pf && typeof pf.tickSize==='string'){
        const ts=pf.tickSize; priceDecimals = ts.includes('.') ? Math.max(0, ts.replace(/0+$/,'').split('.')[1].length) : 0;
      } else if (typeof s.pricePrecision==='number'){ priceDecimals=s.pricePrecision; }
      let qtyDecimals=8;
      if (lf && typeof lf.stepSize==='string'){
        const qs=lf.stepSize; qtyDecimals = qs.includes('.') ? Math.max(0, qs.replace(/0+$/,'').split('.')[1].length) : 0;
      } else if (typeof s.baseAssetPrecision==='number'){ qtyDecimals=s.baseAssetPrecision; }
      priceDecimals=Math.min(8,Math.max(0,priceDecimals));
      qtyDecimals=Math.min(8,Math.max(0,qtyDecimals));
      return {priceDecimals, qtyDecimals};
    }finally{ clearTimeout(t); }
  }
  function fmtPx(n,d){ return Number(n).toLocaleString(undefined,{minimumFractionDigits:d, maximumFractionDigits:d}); }
  function fmtQty(q,d){ return Number(q).toLocaleString(undefined,{maximumFractionDigits:d}); }
  function fmtTime(tsSec){ const d=new Date(tsSec*1000); return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'}); }

  // ---- WS ---- //
  const wsHub = (()=>{
    const BASES=['wss://stream.binance.com:9443/stream','wss://data-stream.binance.vision/stream'];
    let hostIdx=Math.floor(Math.random()*BASES.length);
    let ws=null, connected=false, sendQueue=[];
    const want=new Set();
    const listeners=new Map();
    let backoff=2000; const MAX_BACKOFF=30000;

    function url(){ return BASES[hostIdx%BASES.length]; }
    function ensureOpen(){
      if (ws && (ws.readyState===WebSocket.OPEN || ws.readyState===WebSocket.CONNECTING)) return;
      try{ ws && ws.close(); }catch{}
      ws = new WebSocket(url());
      ws.onopen=()=>{
        connected=true;
        for (const msg of sendQueue){ try{ ws.send(JSON.stringify(msg)); }catch{} }
        sendQueue.length=0;
        if (want.size){ try{ ws.send(JSON.stringify({method:'SUBSCRIBE', params:[...want], id:Date.now()})); }catch{} }
        backoff=2000;
      };
      ws.onclose=()=>{
        connected=false;
        hostIdx=(hostIdx+1)%BASES.length;
        setTimeout(ensureOpen, Math.min(backoff,MAX_BACKOFF)+Math.floor(Math.random()*700));
        backoff=Math.min(Math.round(backoff*1.7),MAX_BACKOFF);
      };
      ws.onerror=()=>{};
      ws.onmessage=(ev)=>{
        let raw; try{ raw=JSON.parse(ev.data); }catch{ return; }
        if (raw && Object.prototype.hasOwnProperty.call(raw,'result')) return; // ack
        const stream=raw.stream||''; const data=raw.data||raw;
        if (!stream) return;
        const [symLower, rest]=stream.split('@');
        const type=(rest||'').toLowerCase();
        const sym = symLower ? symLower.toUpperCase() : '';
        const h=listeners.get(sym);
        if (!sym || !h) return;
        if (type.startsWith('trade')) h({type:'trade', data});
      };
    }
    function send(msg){
      if (connected && ws && ws.readyState===WebSocket.OPEN){
        try{ ws.send(JSON.stringify(msg)); }catch{ sendQueue.push(msg); }
      } else { sendQueue.push(msg); ensureOpen(); }
    }
    function subscribe(sym, handler){
      const base=sym.toLowerCase(); const key=`${base}@trade`;
      let changed=false; if (!want.has(key)){ want.add(key); changed=true; }
      listeners.set(sym.toUpperCase(), handler);
      ensureOpen();
      if (connected && changed) send({method:'SUBSCRIBE', params:[key], id:Date.now()});
    }
    function unsubscribe(sym){
      const base=sym.toLowerCase(); const key=`${base}@trade`;
      if (want.has(key) && connected) send({method:'UNSUBSCRIBE', params:[key], id:Date.now()});
      want.delete(key);
      listeners.delete(sym.toUpperCase());
    }
    return { ensureOpen, subscribe, unsubscribe };
  })();

  // ---- Cards ---- //
  const active = new Map();

  function idsFor(sym){
    const U = sym.toUpperCase();
    return {
      card:'card_'+U, status:'status_'+U,
      priceHead:'price_'+U, priceStat:'priceStat_'+U,
      bstart:'bstart_'+U, blen:'blen_'+U,
      bucket:'bucket_'+U, bars:'bars_'+U,
      vol:'vol_'+U, quote:'quote_'+U, count:'count_'+U, cvd:'cvd_'+U,
      tb:'tb_'+U, ts:'ts_'+U, delta:'delta_'+U
    };
  }

  function createCard(sym){
    const ids=idsFor(sym);
    const card=document.createElement('div');
    card.className='card'; card.id=ids.card;
    card.innerHTML=`
      <div class="head">
        <div class="head-top">
          <span class="pill">${sym}</span>
          <span class="grow"></span>
          <span>Price: <span id="${ids.priceHead}" class="price">—</span></span>
          <button class="close" title="Close card">❌</button>
        </div>
        <div class="head-bottom">
          <span id="${ids.status}" class="status">Connecting…</span>
        </div>
      </div>

      <div class="stats">
        <div class="stat"><h3>Current price</h3><div class="val" id="${ids.priceStat}">—</div></div>
        <div class="stat"><h3>Active candle start</h3><div class="val" id="${ids.bstart}">–</div></div>
        <div class="stat"><h3>Active candle length</h3><div class="val"><span id="${ids.blen}">60</span> s</div></div>
        <div class="stat"><h3>Taker Buy (active candle)</h3><div class="val" id="${ids.tb}">0</div></div>
        <div class="stat"><h3>Taker Sell (active candle)</h3><div class="val" id="${ids.ts}">0</div></div>
        <div class="stat"><h3>Net (Buy − Sell)</h3><div class="val" id="${ids.delta}">0</div></div>
      </div>

      <div class="controls">
        <label>Time window:
          <select id="${ids.bucket}">
            <option value="5">5s</option><option value="10">10s</option><option value="15">15s</option>
            <option value="30">30s</option><option value="60">1m</option><option value="120">2m</option>
            <option value="300">5m</option><option value="900">15m</option>
          </select>
        </label>
        <label>Bars:
          <select id="${ids.bars}">
            <option>30</option><option selected>60</option><option>120</option><option>240</option>
          </select>
        </label>
        <span class="muted">Source: Binance Spot (@trade)</span>
      </div>

      <div class="charts">
        <div class="chart-wrap vol"><canvas id="${ids.vol}"></canvas></div>
        <div class="chart-wrap quote"><canvas id="${ids.quote}"></canvas></div>
        <div class="chart-wrap count"><canvas id="${ids.count}"></canvas></div>
        <div class="chart-wrap cvd"><canvas id="${ids.cvd}"></canvas></div>
      </div>
    `;
    card.querySelector('.close').addEventListener('click', ()=> removeSymbol(sym));
    grid.appendChild(card);
    return card;
  }

  function setStatus(sym, text){
    const el=document.getElementById(idsFor(sym).status);
    if (el) el.textContent=text;
  }

  function removeSymbol(sym){
    wsHub.unsubscribe(sym);
    const rec=active.get(sym);
    if (rec){
      if (rec.guard) clearTimeout(rec.guard);
      if (rec.raf) cancelAnimationFrame(rec.raf);
      if (rec.ro) try{ rec.ro.disconnect(); }catch{}
      if (rec.backfillAbort) try{ rec.backfillAbort.abort(); }catch{}
      try{
        rec.charts.vol.destroy(); rec.charts.quote.destroy();
        rec.charts.count.destroy(); rec.charts.cvd.destroy();
      }catch{}
    }
    active.delete(sym);
    const c=document.getElementById(idsFor(sym).card); if (c) c.remove();
    saveList();
  }

  // ---- Series ---- //
  function bucketStart(rec, eventMs){ const s=Math.floor(eventMs/1000); return s - (s % rec.bucketSec); }
  function rotateBucketIfNeeded(rec, eventMs){
    const start=bucketStart(rec, eventMs);
    const ids=idsFor(rec.sym);
    if (rec.activeStart===null){
      rec.activeStart=start;
      const el=document.getElementById(ids.bstart); if (el) el.textContent=fmtTime(start);
      return;
    }
    if (start!==rec.activeStart){
      rec.bars.push({
        t:rec.activeStart,
        tb:rec.activeTB, ts:rec.activeTS,
        tbQ:rec.activeTBQ, tsQ:rec.activeTSQ,
        tbC:rec.buyCnt,   tsC:rec.sellCnt
      });
      if (rec.bars.length>rec.maxBars-1) rec.bars=rec.bars.slice(-(rec.maxBars-1));
      rec.activeStart=start;
      const el=document.getElementById(ids.bstart); if (el) el.textContent=fmtTime(start);
      rec.activeTB=rec.activeTS=0;
      rec.activeTBQ=rec.activeTSQ=0;
      rec.buyCnt=rec.sellCnt=0;
    }
  }
  function computeSeries(rec){
    let labels=rec.bars.map(b=>fmtTime(b.t));
    let buyQty=rec.bars.map(b=>b.tb), sellQty=rec.bars.map(b=>b.ts);
    let buyQ=rec.bars.map(b=>b.tbQ||0), sellQ=rec.bars.map(b=>b.tsQ||0);
    let buyC=rec.bars.map(b=>b.tbC||0), sellC=rec.bars.map(b=>b.tsC||0);
    if (rec.activeStart!==null){
      labels.push(fmtTime(rec.activeStart));
      buyQty.push(rec.activeTB); sellQty.push(rec.activeTS);
      buyQ.push(rec.activeTBQ);  sellQ.push(rec.activeTSQ);
      buyC.push(rec.buyCnt);     sellC.push(rec.sellCnt);
    }
    if (labels.length>rec.maxBars){
      const s=labels.length-rec.maxBars;
      labels=labels.slice(s); buyQty=buyQty.slice(s); sellQty=sellQty.slice(s);
      buyQ=buyQ.slice(s); sellQ=sellQ.slice(s); buyC=buyC.slice(s); sellC=sellC.slice(s);
    }
    return {labels, buyQty, sellQty, buyQ, sellQ, buyC, sellC};
  }
  function computeCVD(buyQty,sellQty){ const out=[]; let acc=0; for(let i=0;i<buyQty.length;i++){ acc+=(Number(buyQty[i]||0)-Number(sellQty[i]||0)); out.push(acc);} return out; }

  function scheduleDraw(sym){
    const rec=active.get(sym); if (!rec) return;
    if (rec.needsDraw) return;
    rec.needsDraw=true;
    rec.raf=requestAnimationFrame(()=>{ rec.needsDraw=false; redraw(sym); });
  }
  function redraw(sym){
    const rec=active.get(sym); if(!rec) return;
    const ids=idsFor(sym);
    const {labels,buyQty,sellQty,buyQ,sellQ,buyC,sellC}=computeSeries(rec);
    const cvd=computeCVD(buyQty,sellQty);

    rec.charts.vol.data.labels=labels;
    rec.charts.vol.data.datasets[0].data=buyQty;
    rec.charts.vol.data.datasets[1].data=sellQty;
    rec.charts.vol.update('none');

    rec.charts.quote.data.labels=labels;
    rec.charts.quote.data.datasets[0].data=buyQ;
    rec.charts.quote.data.datasets[1].data=sellQ;
    rec.charts.quote.update('none');

    rec.charts.count.data.labels=labels;
    rec.charts.count.data.datasets[0].data=buyC;
    rec.charts.count.data.datasets[1].data=sellC;
    rec.charts.count.update('none');

    rec.charts.cvd.data.labels=labels;
    rec.charts.cvd.data.datasets[0].data=cvd;
    rec.charts.cvd.update('none');

    const tb=buyQty.at(-1)||0, ts=sellQty.at(-1)||0, delta=Number(tb)-Number(ts);
    const tbEl=document.getElementById(ids.tb); if (tbEl) tbEl.textContent=Number(tb).toLocaleString();
    const tsEl=document.getElementById(ids.ts); if (tsEl) tsEl.textContent=Number(ts).toLocaleString();
    const dEl=document.getElementById(ids.delta); if (dEl) dEl.textContent=Number(delta).toLocaleString();
  }

  // ---- Backfill ----
  async function backfill(rec){
    if (rec.backfillAbort) try{ rec.backfillAbort.abort(); }catch{}
    const ctrl=new AbortController(); rec.backfillAbort=ctrl;
    setStatus(rec.sym,'Backfill…');
    try{
      const windowMs=Math.max(1,rec.maxBars-1)*rec.bucketSec*1000;
      const cutoff=Date.now()-windowMs;
      let start=cutoff; let pages=0; const MAX_PAGES=12;

      while(pages<MAX_PAGES && !ctrl.signal.aborted){
        const url=`https://api.binance.com/api/v3/aggTrades?symbol=${encodeURIComponent(rec.sym)}&startTime=${start}&limit=1000`;
        const timeout=setTimeout(()=>ctrl.abort(),5000);
        let resp; try{ resp=await fetch(url,{cache:'no-store',signal:ctrl.signal}); } finally{ clearTimeout(timeout); }
        if (!resp || !resp.ok) break;
        const arr=await resp.json(); if (!Array.isArray(arr) || !arr.length) break;

        for (const t of arr){
          const evMs=t.T; if (evMs<cutoff) continue;
          rotateBucketIfNeeded(rec, evMs);
          const q=parseFloat(t.q), p=parseFloat(t.p); if (!isFinite(q)||q<=0||!isFinite(p)||p<=0) continue;
          const quote=q*p; const cnt=Math.max(1,(t.l - t.f + 1)||1);
          if (t.m){ rec.activeTS+=q; rec.activeTSQ+=quote; rec.sellCnt+=cnt; }
          else    { rec.activeTB+=q; rec.activeTBQ+=quote; rec.buyCnt +=cnt; }
        }
        pages++; start=arr.at(-1).T + 1;
        if (start >= Date.now()-500) break;
      }
      scheduleDraw(rec.sym);
    }catch(e){}
  }

  // ---- Hub + backfill + live ---- //
  async function openSymbol(sym){
    sym=sym.toUpperCase();
    if (active.has(sym)) return;
    if (active.size>=4){ alert('You’ve reached the 4-card limit. Close a card to add a new one.'); return; }

    createCard(sym);
    setStatus(sym,'Connecting…');

    const ids=idsFor(sym);
    const bucketSel=document.getElementById(ids.bucket);
    const barsSel=document.getElementById(ids.bars);
    const priceHead=document.getElementById(ids.priceHead);
    const priceStat=document.getElementById(ids.priceStat);
    const blen=document.getElementById(ids.blen);

    const rec={
      sym,
      bucketSec: loadDefaultBucket(),
      maxBars:   loadDefaultBars(),
      bars:[],
      activeStart:null,
      activeTB:0, activeTS:0,
      activeTBQ:0, activeTSQ:0,
      buyCnt:0, sellCnt:0,
      priceDec:8, qtyDec:8,
      buffer:[], backfilling:true,
      charts:{},
      ro:null, raf:null, needsDraw:false, guard:null, backfillAbort:null
    };
    active.set(sym,rec);

    (async()=>{ const info=await fetchExchangeInfo(sym); if(info){ rec.priceDec=info.priceDecimals; rec.qtyDec=info.qtyDecimals; } })();

    bucketSel.value=String(rec.bucketSec);
    barsSel.value=String(rec.maxBars);
    blen.textContent=String(rec.bucketSec);

    // Charts
    function mkBarOptions(stacked=true){
      return {
        responsive:true, maintainAspectRatio:false, animation:false,
        layout:{padding:{left:8,right:8,top:8,bottom:4}},
        plugins:{
          legend:{labels:{color:'#cbd5e1'}},
          tooltip:{callbacks:{ title:it=>it[0]?.label||'', label:it=>`${it.dataset.label}: ${Number(it.raw).toLocaleString()}` }}
        },
        scales:{
          x:{ticks:{color:'#94a3b8',maxRotation:0,autoSkip:true,maxTicksLimit:12},grid:{color:'#1e293b'},stacked},
          y:{beginAtZero:true,stacked,ticks:{color:'#94a3b8'},grid:{color:'#1e293b'}}
        }
      };
    }
    function mkCvdOptions(){
      return {
        responsive:true, maintainAspectRatio:false, animation:false,
        layout:{padding:{left:8,right:8,top:4,bottom:4}},
        plugins:{ legend:{labels:{color:'#cbd5e1'}}, tooltip:{callbacks:{title:it=>it[0]?.label||'', label:it=>`CVD: ${Number(it.raw).toLocaleString()}`}}},
        scales:{ x:{ticks:{color:'#94a3b8',maxRotation:0,autoSkip:true,maxTicksLimit:12},grid:{color:'#1e293b'}},
                 y:{beginAtZero:false,ticks:{color:'#94a3b8'},grid:{color:'#1e293b'}} }
      };
    }
    rec.charts.vol   = new Chart(document.getElementById(ids.vol),   {data:{labels:[],datasets:[
      {type:'bar',label:'Taker Buy (quantity)',yAxisID:'y',stack:'qty',data:[],backgroundColor:'rgba(34,197,94,0.7)',borderColor:'rgba(34,197,94,1)',borderWidth:0,barPercentage:0.9,categoryPercentage:0.9},
      {type:'bar',label:'Taker Sell (quantity)',yAxisID:'y',stack:'qty',data:[],backgroundColor:'rgba(239,68,68,0.7)',borderColor:'rgba(239,68,68,1)',borderWidth:0,barPercentage:0.9,categoryPercentage:0.9}
    ]}, options: mkBarOptions(true)});
    rec.charts.quote = new Chart(document.getElementById(ids.quote), {data:{labels:[],datasets:[
      {type:'bar',label:'Taker Buy (quote)',yAxisID:'y',stack:'q',data:[],backgroundColor:'rgba(34,197,94,0.7)',borderColor:'rgba(34,197,94,1)',borderWidth:0,barPercentage:0.9,categoryPercentage:0.9},
      {type:'bar',label:'Taker Sell (quote)',yAxisID:'y',stack:'q',data:[],backgroundColor:'rgba(239,68,68,0.7)',borderColor:'rgba(239,68,68,1)',borderWidth:0,barPercentage:0.9,categoryPercentage:0.9}
    ]}, options: mkBarOptions(true)});
    rec.charts.count = new Chart(document.getElementById(ids.count), {data:{labels:[],datasets:[
      {type:'bar',label:'Taker Buy (trades)',yAxisID:'y',stack:'c',data:[],backgroundColor:'rgba(34,197,94,0.7)',borderColor:'rgba(34,197,94,1)',borderWidth:0,barPercentage:0.9,categoryPercentage:0.9},
      {type:'bar',label:'Taker Sell (trades)',yAxisID:'y',stack:'c',data:[],backgroundColor:'rgba(239,68,68,0.7)',borderColor:'rgba(239,68,68,1)',borderWidth:0,barPercentage:0.9,categoryPercentage:0.9}
    ]}, options: mkBarOptions(true)});
    rec.charts.cvd   = new Chart(document.getElementById(ids.cvd),   {type:'line',data:{labels:[],datasets:[
      {label:'CVD',data:[],borderColor:'rgba(59,130,246,1)',backgroundColor:'rgba(59,130,246,0.15)',borderWidth:2,pointRadius:0,tension:0.2}
    ]}, options: mkCvdOptions()});

    rec.ro=new ResizeObserver(()=>{ rec.charts.vol.resize(); rec.charts.quote.resize(); rec.charts.count.resize(); rec.charts.cvd.resize(); });
    rec.ro.observe(document.getElementById(ids.card));

    bucketSel.addEventListener('change', async ()=>{
      rec.bucketSec=parseInt(bucketSel.value,10)||60; blen.textContent=String(rec.bucketSec);
      rec.bars=[]; rec.activeStart=null; rec.activeTB=rec.activeTS=0; rec.activeTBQ=rec.activeTSQ=0; rec.buyCnt=rec.sellCnt=0;
      scheduleDraw(sym);
      await backfill(rec);
    });
    barsSel.addEventListener('change', async ()=>{
      const prev=rec.maxBars; rec.maxBars=parseInt(barsSel.value,10)||60; scheduleDraw(sym);
      if (rec.maxBars>prev) await backfill(rec);
    });

    // WS Subscribe
    wsHub.subscribe(sym, ({type,data})=>{
      if (type!=='trade') return;
      const t=data;
      const price=parseFloat(t.p), qty=parseFloat(t.q), evMs=t.E;
      if (!isFinite(price)||!isFinite(qty)||qty<=0) return;

      if (priceHead) priceHead.textContent = fmtPx(price, rec.priceDec);
      if (priceStat) priceStat.textContent = fmtPx(price, rec.priceDec);

      if (rec.backfilling){
        rec.buffer.push({evMs, price, qty, m:!!t.m});
        return;
      }

      rotateBucketIfNeeded(rec, evMs);
      const quote=qty*price;
      if (t.m){ rec.activeTS+=qty; rec.activeTSQ+=quote; rec.sellCnt++; }
      else    { rec.activeTB+=qty; rec.activeTBQ+=quote; rec.buyCnt++; }
      scheduleDraw(sym);
    });

    await backfill(rec);
    if (!active.has(sym)) return;
    rec.buffer.sort((a,b)=>a.evMs-b.evMs);
    for (const e of rec.buffer){
      rotateBucketIfNeeded(rec, e.evMs);
      const quote=e.qty*e.price;
      if (e.m){ rec.activeTS+=e.qty; rec.activeTSQ+=quote; rec.sellCnt++; }
      else    { rec.activeTB+=e.qty; rec.activeTBQ+=quote; rec.buyCnt++; }
    }
    rec.buffer.length=0; rec.backfilling=false;
    setStatus(sym,'Live');
    scheduleDraw(sym);

    saveList();
  }

  // ---- Add / input ---- //
  symbolsInput.value=localStorage.getItem(LS.lastInput)||'';
  symbolsInput.addEventListener('input', ()=> localStorage.setItem(LS.lastInput, symbolsInput.value));
  symbolsInput.addEventListener('keydown', e=>{ if(e.key==='Enter') addSymbolsFromInput(); });
  addBtn.addEventListener('click', addSymbolsFromInput);
  clearBtn.addEventListener('click', ()=> Array.from(active.keys()).forEach(removeSymbol));

  function addSymbolsFromInput(){
    const raw=symbolsInput.value.trim();
    if (!raw){ symbolsInput.value=Array.from(active.keys()).join(','); return; }
    const syms=parsePairs(raw); if (!syms.length) return;
    const newOnes=syms.filter(s=>!active.has(s));
    let remaining=4-active.size;
    if (remaining<=0){ alert('You’ve reached the 4-card limit. Close a card to add a new one.'); return; }
    const toOpen=newOnes.slice(0,remaining);
    const skipped=newOnes.slice(remaining);
    toOpen.forEach(openSymbol);
    if (skipped.length) alert('Skipped due to the 4-card limit: '+skipped.join(', '));
    symbolsInput.value=''; localStorage.setItem(LS.lastInput,'');
  }

  // ---- Settings drawer ---- //
  btnSettings.addEventListener('click', ()=>{
    defPairsEl.value = loadUserDefaults().join(', ');
    defBucketEl.value= String(loadDefaultBucket());
    defBarsEl.value  = String(loadDefaultBars());
    drawer.classList.add('open');
  });
  btnCloseSettings.addEventListener('click', ()=> drawer.classList.remove('open'));

  btnSaveDefaults.addEventListener('click', ()=>{
    let arr=parsePairs(defPairsEl.value);
    arr=Array.from(new Set(arr)).slice(0,4);
    defPairsEl.value=arr.join(', ');
    try{
      localStorage.setItem(LS.defPairs, JSON.stringify(arr.length?arr:DEFAULT_PAIRS.slice(0,4)));
      localStorage.setItem(LS.defBucket, String(parseInt(defBucketEl.value,10)||60));
      localStorage.setItem(LS.defBars,   String(parseInt(defBarsEl.value,10)||60));
    }catch{}
  });

  btnApplyDefaults.addEventListener('click', ()=>{
    let arr=parsePairs(defPairsEl.value);
    arr=Array.from(new Set(arr)).slice(0,4);
    if (!arr.length) arr=DEFAULT_PAIRS.slice(0,4);
    defPairsEl.value=arr.join(', ');
    try{
      localStorage.setItem(LS.defPairs, JSON.stringify(arr));
      localStorage.setItem(LS.defBucket, String(parseInt(defBucketEl.value,10)||60));
      localStorage.setItem(LS.defBars,   String(parseInt(defBarsEl.value,10)||60));
    }catch{}

    Array.from(active.keys()).forEach(removeSymbol);

    wsHub.ensureOpen();
    arr.forEach(openSymbol);
    drawer.classList.remove('open');
  });

  // ---- Help drawer ---- //
  btnHelp.addEventListener('click', ()=> helpDrawer.classList.add('open'));
  btnCloseHelp.addEventListener('click', ()=> helpDrawer.classList.remove('open'));

  // ---- INIT ---- //
  (function init(){
    wsHub.ensureOpen();
    loadList().forEach(openSymbol);
  })();

  // ---- Clean ---- //
  window.addEventListener('beforeunload', ()=>{
    for (const s of active.keys()) wsHub.unsubscribe(s);
  });
})();
</script>
</body>
</html>
